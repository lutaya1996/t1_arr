# **PSR-5: PHPDoc**

https://github.com/php-fig/fig-standards/blob/master/proposed/phpdoc.md#1-introduction

## **Описание**

* «PHPDoc» — это раздел документации, в котором содержится информация об аспектах «Структурного элемента».

Важно отметить, что PHPDoc и DocBlock — это два отдельных объекта. DocBlock представляет собой комбинацию DocComment, который является типом комментария, и объекта PHPDoc. Это объект PHPDoc, который содержит синтаксис, описанный в этой спецификации (например, описание и теги).

* «Структурный элемент» — это набор программных конструкций, которым МОЖЕТ предшествовать DocBlock. Коллекция содержит следующие конструкции:

   * require(_once)
   * include(_once)
   * class
   * interface
   * trait
   * function (including methods)
   * property
   * constant
   * variables, both local and global scope.

РЕКОМЕНДУЕТСЯ ставить перед «Структурным элементом» DocBlock там, где он определен, а не при каждом использовании. Общепринятой практикой является размещение DocBlock перед структурным элементом, но он также МОЖЕТ быть разделен неопределенным количеством пустых строк. Например:

~~~
/** @var int $int This is a counter. */
$int = 0;

// there should be no docblock here
$int++;
~~~

#### или

~~~
/**
 * This class acts as an example on where to position a DocBlock.
 */
class Foo
{
    /** @var string|null $title contains a title for the Foo */
    protected $title = null;

    /**
     * Sets a single-line title.
     *
     * @param string $title A text for the title.
     *
     * @return void
     */
    public function setTitle($title)
    {
        // there should be no docblock here
        $this->title = $title;
    }
}
~~~

НЕ РЕКОМЕНДУЕТСЯ использовать составные определения для Констант или Свойства, так как обработка DocBlocks в этих ситуациях может привести к неожиданным результатам. Если используется составной оператор, каждый элемент ДОЛЖЕН иметь предшествующий DocBlock. Пример:

~~~
  class Foo
  {
    protected
      /**
       * @var string Should contain a description
       */
      $name,
      /**
       * @var string Should contain a description
       */
      $description;
  }
  ~~~

Примером использования, выходящим за рамки настоящего стандарта, является явное документирование переменной в foreach; некоторые IDE используют эту информацию, чтобы помочь своим функциям автозаполнения.

Этот стандарт не распространяется на этот конкретный случай, поскольку foreachоператор считается оператором «потока управления», а не «структурным элементом».

~~~
/** @var \Sqlite3 $sqlite */
foreach ($connections as $sqlite) {
    // there should be no docblock here
    $sqlite->open('/my/database/path');
    <...>
}
~~~

  * DocComment» — это особый тип комментария, который ДОЛЖЕН

      * начинаться с последовательности символов /**, за которой следует пробельный символ
      * закончиться с */и
      * иметь ноль или более строк между ними.
     
 В случае, когда DocComment занимает несколько строк, каждая строка ДОЛЖНА начинаться со звездочки ( *), которая ДОЛЖНА быть выровнена с первой звездочкой открывающего предложения.

Пример одной строки:

         /** <...> */

Многострочный пример:

          /**
         * <...>
         */

* «DocBlock» — это «DocComment», содержащий единую структуру «PHPDoc» и представляющий базовое представление в исходном коде.

* «Тег» — это отдельная часть метаинформации, касающаяся «Структурного элемента» или его компонента.

* «Тип» — это определение того, какой тип данных связан с элементом. Это обычно используется при определении точных значений аргументов, констант, свойств и многого другого.

Для каждого типа «Структурного элемента» могут использоваться следующие обозначения:

   * Пространство имен : \My\Space
   * Функция : \My\Space\myFunction()
   * Константа : \My\Space\MY_CONSTANT
   * Класс : \My\Space\MyClass
   * Интерфейс : \My\Space\MyInterface
   * Черта : \My\Space\MyTrait
   * Метод : \My\Space\MyClass::myMethod()
   * Недвижимость : \My\Space\MyClass::$my_property
   * Константа класса :\My\Space\MyClass::MY_CONSTANT

## **Основные принципы**

* PHPDoc всегда ДОЛЖЕН содержаться в "DocComment"; комбинация этих двух называется «DocBlock».

* DocBlock ДОЛЖЕН непосредственно предшествовать «Структурному элементу».

## **Формат PHPDoc**

PHPDoc             = [summary] [description] [tags]

   ### **Краткое содержание**

   Резюме ДОЛЖНО содержать резюме «Структурного элемента», определяющего цель. РЕКОМЕНДУЕТСЯ, чтобы Резюме занимало одну или максимум две строки, но не более того.

   Резюме ДОЛЖНО заканчиваться двумя последовательными разрывами строк, если только оно не является единственным содержимым в PHPDoc.

   Если предоставлено описание, то ему ДОЛЖНО предшествовать резюме. В противном случае Описание будет считаться Сводкой до тех пор, пока не будет достигнут конец Сводки.

   Поскольку Резюме можно сравнить с названием главы, полезно использовать как можно меньше форматирования. Таким образом, вопреки описанию (см. следующую главу), не делается никаких рекомендаций по поддержке языка разметки. Это явно оставлено на усмотрение реализующего приложения, хочет ли оно поддерживать это или нет.

   ### **Описание**

   Описание является НЕОБЯЗАТЕЛЬНЫМ, но его СЛЕДУЕТ включать, когда «Структурный элемент», которому предшествует этот DocBlock, содержит больше или более сложные операции, чем может быть описано только в сводке.

   Любому приложению, анализирующему описание, РЕКОМЕНДУЕТСЯ поддерживать язык разметки Markdown для этого поля, чтобы автор мог обеспечить форматирование и четкий способ представления примеров кода.

   Обычно описание используется (среди прочего):

   * Чтобы предоставить более подробную информацию, чем сводка, о том, что делает этот метод.
   * Чтобы указать, из каких дочерних элементов состоит входной или выходной массив или объект.
   * Предоставить набор общих вариантов использования или сценариев, в которых может применяться «Структурный элемент».

   ### **Теги**

   Теги позволяют авторам предоставлять краткие метаданные о последующем «Структурном элементе». Каждый тег начинается с новой строки, за ним следует знак @ и имя тега, за которым следует пробел и метаданные (включая описание).

   Если предоставлены метаданные, они МОГУТ охватывать несколько строк и МОГЛИ следовать строгому формату и, таким образом, предоставлять параметры в соответствии с типом тега. Тип тега может быть получен из его имени.

   Например:

            @param string $argument1 This is a parameter.

   Описание тега ДОЛЖНО поддерживать Markdown в качестве языка форматирования. Из-за характера уценки допустимо начинать описание тега с той же или последующей строки и интерпретировать его таким же образом.

   Таким образом, следующие теги семантически идентичны:

            /**
         * @var string This is a description.
         * @var string This is a
         *    description.
         * @var string
         *    This is a description.
         */

   Вариантом этого является то, что вместо описания используется подпись тега; в большинстве случаев тег фактически будет «Аннотацией». Сигнатура тега может предоставить аннотации параметры, касающиеся ее работы.

   Если присутствует подпись тега, то НЕ ДОЛЖНО присутствовать описание в том же теге.

   Метаданные, предоставляемые тегами, могут привести к изменению фактического поведения следующего «структурного элемента» во время выполнения, и в этом случае вместо «тега» обычно используется термин «аннотация».

    #### **Название тэга**

   Имена тегов указывают, какой тип информации представлен этим тегом, или, в случае аннотаций, какое поведение должно быть введено в последующий «Структурный элемент».

   В поддержку аннотаций допускается введение набора тегов, разработанных специально для отдельного приложения или подмножества приложений (и, следовательно, не охватываемых данной спецификацией).

   Эти теги или аннотации ДОЛЖНЫ предоставлять пространство имен либо

   * префикс имени тега с пространством имен в стиле PHP или
   * префикс имени тега с одним именем поставщика, за которым следует дефис.
   Пример имени тега с префиксом пространства имен в стиле php (косая черта перед префиксом НЕОБЯЗАТЕЛЬНА):

            @\Doctrine\Orm\Mapping\Entity()
            Примечание . Стандарт PHPDoc НЕ делает предположений о значении тега, если только это не указано в этом документе или последующих дополнениях или расширениях.

            Это означает, что вы МОЖЕТЕ использовать псевдонимы пространства имен, если предоставляется префиксный элемент пространства имен. Таким образом, следующее также является законным:

                     @Mapping\Entity()

            Ваша собственная библиотека или приложение могут проверять псевдонимы пространств имен и создавать из них FQCN; это не влияет на настоящий стандарт.

            Важно : инструменты, использующие стандарт PHPDoc, МОГУТ интерпретировать пространства имен, которые зарегистрированы в этом приложении, и применять настраиваемое поведение.

   Пример имени тега с префиксом имени поставщика и дефисом:

            @phpdoc-event transformer.transform.pre

   Имена тегов без префикса поставщика или пространства имен ДОЛЖНЫ быть описаны в PSR Каталога тегов и/или любом официальном приложении.

   #### **Специализация тегов**

   Чтобы предоставить метод, с помощью которого можно придать нюансы тегам, определенным в этом стандарте, но без расширения базового набора, после имени тега МОЖЕТ быть предоставлена ​​специализация тега путем добавления двоеточия, за которым следует строка, обеспечивающая более подробное описание. тега. Список поддерживаемых специализаций тегов не сохраняется в каталоге тегов PSR , так как он может меняться со временем. Метадокумент PSR каталога тегов может содержать ряд рекомендаций для каждого имени тега, но проекты могут свободно выбирать свою собственную специализацию тегов, если это применимо.

   Важно : инструменты, использующие стандарт PHPDoc, МОГУТ интерпретировать специализации тегов, которые зарегистрированы/поняты этим приложением, и применять настраиваемое поведение, но ожидается, что они реализуют только предшествующее имя тега, как определено в каталоге тегов PSR .

   Например:

            @see:unit-test \Mapping\EntityTest::testGetId

         Вышеприведенный тег состоит из имени («см.») и специализации тега («модуль-тест») и, таким образом, определяет отношение к модульному тесту для текущего метода.

   #### **Подпись тега**

   Подписи тегов обычно используются для аннотаций для предоставления дополнительных метаданных, характерных для текущего тега.

   Предоставленные метаданные могут влиять на поведение аннотации-владельца и, таким образом, влиять на поведение последующего «Структурного элемента».

   Содержимое подписи должно определяться типом тега (как описано в имени тега) и выходит за рамки данной спецификации. Однако за подписью тега НЕ ДОЛЖНО следовать описание или другая форма метаданных.

   ## **Примеры**

   Следующие примеры служат для иллюстрации основного использования DocBlocks; рекомендуется прочитать список тегов в каталоге тегов PSR .

   Полный пример может выглядеть так:

            /**
         * This is a Summary.
         *
         * This is a Description. It may span multiple lines
         * or contain 'code' examples using the _Markdown_ markup
         * language.
         *
         * @see Markdown
         *
         * @param int        $parameter1 A parameter description.
         * @param \Exception $e          Another parameter description.
         *
         * @\Doctrine\Orm\Mapper\Entity()
         *
         * @return string
         */
         function test($parameter1, $e)
         {
            ...
         }

   Также допускается опускать Описание:

            /**
         * This is a Summary.
         *
         * @see Markdown
         *
         * @param int        $parameter1 A parameter description.
         * @param \Exception $parameter2 Another parameter description.
         *
         * @\Doctrine\Orm\Mapper\Entity()
         *
         * @return string
         */
         function test($parameter1, $parameter2)
         {
         }

   DocBlock также может занимать одну строку:

         /** @var \ArrayObject $array */
         public $array = null;

## **Типы**

Когда используется «Тип», пользователь будет ожидать значение или набор значений, как подробно описано ниже.

Когда «Тип» состоит из нескольких типов, они ДОЛЖНЫ быть разделены либо знаком вертикальной черты (|) для типа объединения, либо амперсандом (&) для типа пересечения. Любой интерпретатор, поддерживающий эту спецификацию, ДОЛЖЕН распознать это и разделить «Тип» перед оценкой.

Пример типа союза:

         @return int|null

Пример типа перекрестка:

         @var \MyClass&\PHPUnit\Framework\MockObject\MockObject $myMockObject

### **Массивы**

Значение, представленное «Типом», может быть массивом. Тип ДОЛЖЕН быть определен в соответствии с форматом одной из следующих опций:

1. unspecified: определение содержимого представляемого массива не дается. Пример:
         
         @return array

2. содержащий один тип: определение типа информирует читателя о типе каждого значения массива. В этом случае для каждого значения в данном массиве ожидается только один тип.

Пример:

         @return int[]

Обратите внимание, что смешанный также является одним типом, и с помощью этого ключевого слова можно указать, что каждое значение массива содержит любой возможный тип.

3. указано как содержащее несколько типов: определение типа информирует читателя о типе каждого значения массива. Каждое значение может быть любого из заданных типов. 
Пример:
         
         @return (int|string)[]

## **Допустимое имя класса**

Допустимое имя класса отображается в зависимости от контекста, в котором упоминается этот тип. Таким образом, это может быть либо полное имя класса (FQCN), либо локальное имя, если оно присутствует в пространстве имен.

Элемент, к которому применяется этот тип, является либо экземпляром этого класса, либо экземпляром класса, который является (под) дочерним по отношению к данному классу.

      Из-за вышеуказанного характера РЕКОМЕНДУЕТСЯ для приложений, которые собирают и формируют эту информацию, отображать список дочерних классов с каждым представлением класса. Это сделало бы очевидным для пользователя, какие классы приемлемы в качестве типа.

### **Ключевое слово**

Ключевое слово определяет назначение этого типа. Не каждый элемент определяется классом, но все же заслуживает классификации, чтобы помочь разработчику понять код, охватываемый DocBlock.

Примечание:

      Большинство из этих ключевых слов разрешены в качестве имен классов в PHP, и их трудно отличить от реальных классов. Таким образом, ключевые слова ДОЛЖНЫ быть строчными, так как большинство имен классов начинаются с первого символа в верхнем регистре, и вы НЕ ДОЛЖНЫ использовать классы с такими именами в своем коде.

      Есть и другие причины не называть классы именами этих ключевых слов, но это выходит за рамки данной спецификации.

В этом PSR распознаются следующие ключевые слова:

1. bool: элемент, к которому применяется этот тип, имеет только состояние TRUEили FALSE.

2. int: элемент, к которому применяется этот тип, является целым числом или целым числом.

3. float: элемент, к которому применяется этот тип, является непрерывным или действительным числом.

4. string: элемент, к которому применяется этот тип, представляет собой строку двоичных символов.

5. object: элемент, к которому применяется этот тип, является экземпляром неопределенного класса.

6. array: элемент, к которому применяется этот тип, представляет собой массив значений.

7. iterable: элемент, к которому применяется этот тип, является массивом или объектом Traversable в соответствии с определением PHP .

8. resource: элемент, к которому применяется этот тип, является ресурсом согласно определению PHP .

9. mixed: элемент, к которому применяется этот тип, может быть любого типа, указанного здесь. Во время компиляции неизвестно, какой тип будет использоваться.

10. void: этот тип обычно используется только при определении возвращаемого типа метода или функции, указывая, что «ничего не возвращается», и поэтому пользователь не должен полагаться на какое-либо возвращаемое значение.

**Пример 1:**

         /**
         * @return void
         */
         function outputHello()
         {
            echo 'Hello world';
         }

В приведенном выше примере оператор возврата не указан, и поэтому возвращаемое значение не определено.

**Пример 2:**

         /**
         * @param bool $quiet when true 'Hello world' is echo-ed.
         *
         * @return void
         */
         function outputHello($quiet)
         {
            if ($quiet) {
               return;
            }
            echo 'Hello world';
         }

В этом примере функция содержит оператор return без заданного значения. Поскольку фактическое значение не указано, это также квалифицируется как тип void.

11. null: элемент, к которому применяется этот тип, является NULLзначением или, с технической точки зрения, не существует.

Большая разница по сравнению с voidтем, что этот тип используется в любой ситуации, когда описываемый элемент может в любой момент времени содержать явное NULLзначение.

**Пример 1:**

         /**
         * @return null
         */
         function foo()
         {
            echo 'Hello world';
            return null;
         }

Этот тип обычно используется в сочетании с другим типом, чтобы указать, что, возможно, ничего не возвращается.

**Пример 2:**

         /**
         * @param bool $create_new When true returns a new stdClass.
         *
         * @return stdClass|null
         */
         function foo($create_new)
         {
            if ($create_new) {
               return new stdClass();
            }
            return null;
         }

12. callable: элемент, к которому применяется этот тип, является указателем на вызов функции. Это может быть любой тип вызываемого объекта в соответствии с определением PHP .

13. falseили true: элемент, к которому применяется этот тип, будет иметь значение TRUEили FALSE. Никакое другое значение не будет возвращено из этого элемента.

14. self: элемент, к которому применяется этот тип, относится к тому же классу, в котором изначально содержится задокументированный элемент.

**Пример:**

         Метод c содержится в классе A . DocBlock указывает, что его возвращаемое значение имеет тип self. Таким образом, метод c возвращает экземпляр класса A.

Это может привести к запутанным ситуациям, когда речь идет о наследовании.

Пример (предыдущая примерная ситуация остается в силе):

         Класс B расширяет класс A и не переопределяет метод c . Таким образом, можно вызвать метод c из класса B.

В этой ситуации может возникнуть неоднозначность, которую self можно интерпретировать либо как класс A , либо как B. В этих случаях self ДОЛЖЕН интерпретироваться как экземпляр класса, в котором selfзаписан DocBlock, содержащий тип.

В приведенных выше примерах self ДОЛЖЕН всегда ссылаться на класс A , поскольку он определен с помощью метода c в классе A.

         Из-за вышеуказанного характера РЕКОМЕНДУЕТСЯ для приложений, которые собирают и формируют эту информацию, отображать список дочерних классов с каждым представлением класса. Это сделало бы очевидным для пользователя, какие классы приемлемы в качестве типа.

15. static: элемент, к которому применяется этот тип, относится к тому же классу, в котором содержится задокументированный элемент, или, если встречается в подклассе, имеет тип этого подкласса, а не исходного класса.

Это ключевое слово ведет себя так же, как ключевое слово для позднего статического связывания (не статический метод, свойство или модификатор переменной), как определено в PHP.

16. $this: элемент, к которому применяется этот тип, является тем же экземпляром, что и текущий класс в данном контексте. Таким образом, этот тип является более строгой версией static, потому что возвращаемый экземпляр должен быть не только того же класса, но и того же экземпляра.

Этот тип часто используется в качестве возвращаемого значения для методов, реализующих шаблон проектирования Fluent Interface .

17. never: означает, что элемент ничего не возвращает и всегда генерирует исключение или ненормально завершает программу (например, вызывая библиотечную функцию exit).